/**
 * @file game.cpp
 *
 * @brief Implements game logic and every method related to the game
 * functionality of Editor class.
 *
 * @see Editor
 *
 * @author Grigoras Vlad Andrei
 */

#include <cmath>

#include "lab_m1/tema01/include/editor.h"

void hw1::Editor::InitGame() {
    this->CleanupEditorResources();

    this->isGameRunning = true;
    this->PlaceSpaceShipStartPosition();
}

void hw1::Editor::PlaceSpaceShipStartPosition() {
    // Compute current center based on components
    this->spaceship->CalculateCenterPosition();

    glm::vec3 offsetToStart =
        spaceship->GetCenterPosition() - GAME_STARTING_POSITION;

    for (auto& object : this->spaceship->components)
        object->SetPosition(object->GetPosition() - offsetToStart);

    this->spaceship->CalculateCenterPosition();
}

void hw1::Editor::PlaceBallStartingPosition() {
    this->gameBall->SetPosition(GAME_BALL_STARTING_POSITION);

    this->gameBall->velocity.x = GAME_BALL_SPEED;
    this->gameBall->velocity.y = GAME_BALL_SPEED;
}

void hw1::Editor::UpdateBallPosition(float deltaTimeSeconds) {
    glm::vec3 nextPositionOffset =
        glm::vec3(this->gameBall->velocity.x, this->gameBall->velocity.y, 0) *
        deltaTimeSeconds;

    glm::vec3 updatedPosition =
        this->gameBall->GetPosition() + nextPositionOffset;
    this->gameBall->SetPosition(updatedPosition);

    // Update AABB for collision
    float radius = this->gameBall->GetRadius();
    this->gameBall->collisionBox.min =
        updatedPosition - glm::vec3(radius, radius, 0);
    this->gameBall->collisionBox.max =
        updatedPosition + glm::vec3(radius, radius, 0);
}

void hw1::Editor::RemoveBrick(const glm::vec3& position) {
    // Find the brick in the vector
    this->gameScore += 10;
    for (auto it = this->bricks.begin(); it != this->bricks.end(); it++) {
        if ((*it).GetPosition() == position) {
            this->bricks.erase(it);
            break;
        }
    }
}

void hw1::Editor::CheckCollisionSpaceShip() {
    glm::vec3 ballPosition = this->gameBall->GetPosition();
    float ballRadius = this->gameBall->GetRadius();

    // For every object, detect if there is a collision with ball.
    for (auto& object : spaceship->components) {
        // Detected collision.
        if (object->collisionBox.IsCollision(gameBall->collisionBox)) {
            /**
             * NOTE: Need to check which type of collision has occured.
             * If there is a vertical collision, we just invert the X speed.
             * If there is a horizontal collision, we calculate new speed based
             * on: - Angle of ball and center of the spaceship.
             *     - Original ball speed.
             */
            float objectLeftBottomEdge = object->collisionBox.min.x;
            float objectRighBottomtEdge = object->collisionBox.max.x;
            float objectLeftTopEdge = object->collisionBox.min.y;
            float objectRightTopEdge = object->collisionBox.max.y;

            float ballBottomLeftEdge = this->gameBall->collisionBox.min.x;
            float ballRight = this->gameBall->collisionBox.max.x;
            float ballBottom = this->gameBall->collisionBox.min.y;
            float ballTop = this->gameBall->collisionBox.max.y;

            float overlapX =
                std::min(ballRight - objectLeftBottomEdge,
                         objectRighBottomtEdge - ballBottomLeftEdge);
            float overlapY = objectRightTopEdge - ballBottom;

            float newX = 0, newY = 0;

            if (overlapX < overlapY) {
                newX = -gameBall->GetXSpeed();
                newY = gameBall->GetYSpeed();
            } else {
                float xSpeed = gameBall->GetXSpeed();
                float ySpeed = gameBall->GetYSpeed();

                float ballSpeed = sqrt(xSpeed * xSpeed + ySpeed * ySpeed);

                float angle = (this->gameBall->position.x -
                               spaceship->GetCenterPosition().x) /
                              ((float)(this->spaceship->highestPosition.x -
                                       this->spaceship->lowestPosition.x) /
                               2);

                newX = ballSpeed * sin(angle);
                newY = ballSpeed * cos(angle);
            }

            gameBall->SetVelocity(newX, newY);

            break;
        }
    }
}

void hw1::Editor::CheckCollisionBricks() {
    glm::vec3 ballPosition = this->gameBall->GetPosition();
    float ballRadius = this->gameBall->GetRadius();

    for (auto it = bricks.begin(); it != bricks.end();) {
        if (it->collisionBox.IsCollision(gameBall->collisionBox)) {
            // Get brick bounds
            float brickLeft = it->collisionBox.min.x;
            float brickRight = it->collisionBox.max.x;
            float brickBottom = it->collisionBox.min.y;
            float brickTop = it->collisionBox.max.y;

            // Get ball bounds
            float ballLeft = this->gameBall->collisionBox.min.x;
            float ballRight = this->gameBall->collisionBox.max.x;
            float ballBottom = this->gameBall->collisionBox.min.y;
            float ballTop = this->gameBall->collisionBox.max.y;

            // Compute overlap along both axes
            float overlapX =
                std::min(ballRight - brickLeft, brickRight - ballLeft);
            float overlapY =
                std::min(ballTop - brickBottom, brickTop - ballBottom);

            // Preserve ball speed magnitude
            float xSpeed = this->gameBall->GetXSpeed();
            float ySpeed = this->gameBall->GetYSpeed();

            float newX = xSpeed;
            float newY = ySpeed;

            if (overlapX < overlapY) {
                newX = -xSpeed;
            } else {
                newY = -ySpeed;
            }

            gameBall->SetVelocity(newX, newY);

            it = bricks.erase(it);
            gameScore += 10;

            if (bricks.empty()) {
                hasGameStarted = false;
                hasWon = true;
            }

            break;
        } else {
            ++it;
        }
    }
}

void hw1::Editor::CheckCollision() {
    glm::vec3 ballPosition = gameBall->GetPosition();

    float radius = gameBall->GetRadius();
    float speed = GAME_BALL_SPEED;

    if (ballPosition.x - radius <= 0.0f || ballPosition.x + radius >= 500.0f)
        gameBall->SetVelocity(-gameBall->GetXSpeed(), gameBall->GetYSpeed());

    if (ballPosition.y + radius >= 266.0f)
        gameBall->SetVelocity(gameBall->GetXSpeed(), -gameBall->GetYSpeed());

    if (ballPosition.y - radius <= 0.0f) {
        numberOfLives--;

        if (this->numberOfLives == 0) {
            this->hasLost = true;
            this->hasGameStarted = false;

            return;
        }

        this->PlaceBallStartingPosition();
        this->PlaceSpaceShipStartPosition();

        return;
    }

    this->CheckCollisionSpaceShip();

    this->CheckCollisionBricks();
}
